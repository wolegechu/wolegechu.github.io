<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Yuchu Luo - 罗宇矗 on Yuchu Luo - 罗宇矗</title>
    <link>/</link>
    <description>Recent content in Yuchu Luo - 罗宇矗 on Yuchu Luo - 罗宇矗</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; 2017 Yuchu Luo</copyright>
    <lastBuildDate>Fri, 02 Jun 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Synchronization (Part I)</title>
      <link>/post/synchronization_1/</link>
      <pubDate>Mon, 01 Jan 2018 00:38:00 +0000</pubDate>
      
      <guid>/post/synchronization_1/</guid>
      <description>

&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#cache-coherence-the-hardware-view&#34;&gt;Cache coherence (the hardware view)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#multicore-caches&#34;&gt;Multicore Caches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#mesi-coherence-protocol&#34;&gt;MESI coherence protocol&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#core-and-bus-actions&#34;&gt;Core and Bus Actions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#cc-numa&#34;&gt;cc-NUMA&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;


&lt;h2 id=&#34;cache-coherence-the-hardware-view&#34;&gt;Cache coherence (the hardware view)&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Important memory system properties

&lt;ul&gt;
&lt;li&gt;Coherence - concerns accesses to a single memory location

&lt;ul&gt;
&lt;li&gt;Must obey program order if access from only CPU&lt;/li&gt;
&lt;li&gt;There is a total order on all updates&lt;/li&gt;
&lt;li&gt;There is bounded latency before everyone sees a write&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Consistency - concerns ordering across memory locations

&lt;ul&gt;
&lt;li&gt;Even with coherence, different CPUs can see the same write happen at different times&lt;/li&gt;
&lt;li&gt;Sequential consistency is what matches our intuition (As if instructions from all CPUs interleaved on one CPU)&lt;/li&gt;
&lt;li&gt;Many architectures offer weaker consistency can still be sufficient to implement thread API&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;multicore-caches&#34;&gt;Multicore Caches&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Performance requires caches

&lt;ul&gt;
&lt;li&gt;Divided into chuncks of bytes called lines (e.g., 64 bytes)&lt;/li&gt;
&lt;li&gt;Caches create an opportunity for cores to disagree about memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Bus-based approaches

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Snoopy&amp;rdquo; protocols, each CPU listens to memory bus&lt;/li&gt;
&lt;li&gt;Use write-through and invalidate when you see a write bits&lt;/li&gt;
&lt;li&gt;Bus-based schemes limit scalability&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Modern CPUs use networks (e.g., hypertransport, QPI)

&lt;ul&gt;
&lt;li&gt;CPUs pass each other messages about cache lines&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;mesi-coherence-protocol&#34;&gt;MESI coherence protocol&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Modified

&lt;ul&gt;
&lt;li&gt;One cache has a valid copy&lt;/li&gt;
&lt;li&gt;That copy is dirty (needs to be written back to memory)&lt;/li&gt;
&lt;li&gt;Must invalidate all copies in other caches before entering this state&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Exclusive

&lt;ul&gt;
&lt;li&gt;Same as Modified except the cache copy is clean&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Shared

&lt;ul&gt;
&lt;li&gt;One or more caches and memory have a valid copy&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Invalid

&lt;ul&gt;
&lt;li&gt;Doesn&amp;rsquo;t contain any data&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Owned (for enhanced &amp;ldquo;MOESI&amp;rdquo; protocal)

&lt;ul&gt;
&lt;li&gt;Memory may contain stale value of data (like Modified state)&lt;/li&gt;
&lt;li&gt;But have to broadcast modifications (sort of like Shared state)&lt;/li&gt;
&lt;li&gt;Can have both one owned and mutiple shared copies of cache line&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;core-and-bus-actions&#34;&gt;Core and Bus Actions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Core

&lt;ul&gt;
&lt;li&gt;Read&lt;/li&gt;
&lt;li&gt;Write&lt;/li&gt;
&lt;li&gt;Evict (modified? must write back)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Bus

&lt;ul&gt;
&lt;li&gt;Read: without intent to modify, data can come from memory or another cache&lt;/li&gt;
&lt;li&gt;Read-exclusive: with intent to modify, must invalidate all other cache copies&lt;/li&gt;
&lt;li&gt;Writeback: contens put on bus and memory is updated&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;cc-numa&#34;&gt;cc-NUMA&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Old machines used &lt;em&gt;dance hall&lt;/em&gt; achitectures

&lt;ul&gt;
&lt;li&gt;Any CPU can &amp;ldquo;dance with&amp;rdquo; any memory equally&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;An alternative: Non-Uniform Memory Access

&lt;ul&gt;
&lt;li&gt;Each CPU has fast access to some &amp;ldquo;close&amp;rdquo; memory&lt;/li&gt;
&lt;li&gt;Slower to access memory that is farther away&lt;/li&gt;
&lt;li&gt;Use a directory to keep track of who is caching what&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Originally for esoteric machines with many CPUs

&lt;ul&gt;
&lt;li&gt;But AMD and then Intel integrated memory controller into CPU&lt;/li&gt;
&lt;li&gt;Faster to access memory controlled by the local socket (or even local die in a multi-chip module)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;cc-NUMA = cache-coherent NUMA

&lt;ul&gt;
&lt;li&gt;Rarely see non-cache-coherent NUMA&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Virtual Memory OS</title>
      <link>/post/vm_os/</link>
      <pubDate>Wed, 27 Dec 2017 00:38:00 +0000</pubDate>
      
      <guid>/post/vm_os/</guid>
      <description>

&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#paging&#34;&gt;Paging&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#working-set-model&#34;&gt;Working set model&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#paging-challenge&#34;&gt;Paging challenge&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#re-starting-instructions&#34;&gt;Re-starting instructions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#what-to-fetch&#34;&gt;What to fetch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#selecting-physical-pages&#34;&gt;Selecting physical pages&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#superpages&#34;&gt;Superpages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#eviction-policies&#34;&gt;Eviction policies&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#starw-man-fifo-eviction&#34;&gt;Starw man: FIFO eviction&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#thrashing&#34;&gt;Thrashing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#details-of-paging&#34;&gt;Details of paging&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#the-user-level-perspective&#34;&gt;The user-level perspective&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#case-study-4-4-bsd&#34;&gt;Case study: 4.4 BSD&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;


&lt;h2 id=&#34;paging&#34;&gt;Paging&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/post/WX20171227-110059.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use disk to simulate larger virtual than physical memory&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;working-set-model&#34;&gt;Working set model&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Disk much, much slower than memory

&lt;ul&gt;
&lt;li&gt;Goal: run at memory speed, not disk speed&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;sup&gt;80&lt;/sup&gt;&amp;frasl;&lt;sub&gt;20&lt;/sub&gt; rule: 20% of memory gets 80% of memory accesses

&lt;ul&gt;
&lt;li&gt;Keep the hot 20% in memory&lt;/li&gt;
&lt;li&gt;Keep the cold 80% on disk&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;paging-challenge&#34;&gt;Paging challenge&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How to resume a process after a fault?

&lt;ul&gt;
&lt;li&gt;Need to save state and resume&lt;/li&gt;
&lt;li&gt;Process might have been in the middle of an instruction!&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What to fetch from disk?

&lt;ul&gt;
&lt;li&gt;Just needed page or more?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What to eject?

&lt;ul&gt;
&lt;li&gt;How to allocate physical pages amongst processes?&lt;/li&gt;
&lt;li&gt;Wchich of a particular process&amp;rsquo;s pages to keep in memory?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;re-starting-instructions&#34;&gt;Re-starting instructions&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Hardware provides kernel with information about page fault

&lt;ul&gt;
&lt;li&gt;Faulting virtual address (In &lt;code&gt;%cr2&lt;/code&gt; reg on x86&amp;ndash;may see it if you midify Pintos &lt;code&gt;page_fault&lt;/code&gt; and use &lt;code&gt;fault_addr&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;Address of instruction that caused fault&lt;/li&gt;
&lt;li&gt;Was the access a read or write? Was it an instruction fetch? Was it caused by user accss to kernel-only memory?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Hardware mush allow resuming after a fault&lt;/li&gt;
&lt;li&gt;Idempotent instructions are easy

&lt;ul&gt;
&lt;li&gt;E.g., simple load or store instruction can be restarted&lt;/li&gt;
&lt;li&gt;Just re-execute any instruction that only accesses one address&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Complex instructions must be re-started, too

&lt;ul&gt;
&lt;li&gt;E.g., x86 move string instructions&lt;/li&gt;
&lt;li&gt;Specify src, dst, count in &lt;code&gt;%esi, %edi, %ecx&lt;/code&gt; registers&lt;/li&gt;
&lt;li&gt;On fault, registers adjusted to resume where move left off&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;what-to-fetch&#34;&gt;What to fetch&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Bring in page that caused page fault&lt;/li&gt;
&lt;li&gt;Pre-fetch surrounding pages?

&lt;ul&gt;
&lt;li&gt;Reading two disk blocks approximately as fast as reading one&lt;/li&gt;
&lt;li&gt;As long as no track/head switch, seek time dominates&lt;/li&gt;
&lt;li&gt;If application exhibits spacial locality, then big win to store and read multiple contiguous pages&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Also pre-zero unused pages in idle loop

&lt;ul&gt;
&lt;li&gt;Need 0-filled pages for stack, heap, anonymously mmapped memory&lt;/li&gt;
&lt;li&gt;Zeroing them only on demand is slower&lt;/li&gt;
&lt;li&gt;Hence, many OSes zero freed pages while CPU is idle&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;selecting-physical-pages&#34;&gt;Selecting physical pages&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;May need to eject some pages

&lt;ul&gt;
&lt;li&gt;More on eviction policy in two slides&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;May also have a choice of physical pages&lt;/li&gt;
&lt;li&gt;Direct-mapped physical caches

&lt;ul&gt;
&lt;li&gt;Virtual -&amp;gt; Physical mapping can affect performance&lt;/li&gt;
&lt;li&gt;In old days: Physical adddredd A conflicts with $kC+A$ (where k is any integer, C is cache size)&lt;/li&gt;
&lt;li&gt;Applications can conflict with each other or themselves&lt;/li&gt;
&lt;li&gt;Scientific application benefit if consecutive virtual pages do not confilict in the cache&lt;/li&gt;
&lt;li&gt;Many other applications do better with random mapping&lt;/li&gt;
&lt;li&gt;There days: CPUs more sophisticated than kC + A&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;superpages&#34;&gt;Superpages&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;How should OS make use of &amp;ldquo;large&amp;rdquo; mappings

&lt;ul&gt;
&lt;li&gt;x86 has &lt;sup&gt;2&lt;/sup&gt;&amp;frasl;&lt;sub&gt;4&lt;/sub&gt; MB pages that might be useful&lt;/li&gt;
&lt;li&gt;Alpha has even more choices: 8KB, 64KB, 512KB, 4MB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Sometimes more pages in L2 cache than TLB entries

&lt;ul&gt;
&lt;li&gt;Don&amp;rsquo;t want costly TLB misses going to main memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Or have two-level TLBs

&lt;ul&gt;
&lt;li&gt;Want to maximize hit rate in faster L1 TLB&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;OS can transparently support superpages

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;reserve&amp;rdquo; appropriate physical pages if possible&lt;/li&gt;
&lt;li&gt;Promote contiguous pages to superpages&lt;/li&gt;
&lt;li&gt;Does complicate evicting (esp. dirty pages) - demote&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;eviction-policies&#34;&gt;Eviction policies&lt;/h2&gt;

&lt;h3 id=&#34;starw-man-fifo-eviction&#34;&gt;Starw man: FIFO eviction&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Evict oldest fetched page in system&lt;/li&gt;
&lt;li&gt;Example-reference string 1,2,3,4,1,2,5,1,2,3,4,5&lt;/li&gt;
&lt;li&gt;3 physical pages: 9 page faults&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;thrashing&#34;&gt;Thrashing&lt;/h2&gt;

&lt;h2 id=&#34;details-of-paging&#34;&gt;Details of paging&lt;/h2&gt;

&lt;h2 id=&#34;the-user-level-perspective&#34;&gt;The user-level perspective&lt;/h2&gt;

&lt;h2 id=&#34;case-study-4-4-bsd&#34;&gt;Case study: 4.4 BSD&lt;/h2&gt;
</description>
    </item>
    
    <item>
      <title>Virtual Memory Hardware</title>
      <link>/post/vm_hardware/</link>
      <pubDate>Tue, 26 Dec 2017 00:38:00 +0000</pubDate>
      
      <guid>/post/vm_hardware/</guid>
      <description>

&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#issues-in-sharing-physical-memory&#34;&gt;Issues in sharing physical memory&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#virtual-memory&#34;&gt;Virtual memory&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#goals&#34;&gt;goals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#virtual-memory-advantages&#34;&gt;Virtual memory advantages&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ideas&#34;&gt;Ideas&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#ideal-1-load-time-linking&#34;&gt;Ideal 1: load-time linking&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#ideal-2-base-bound-register&#34;&gt;Ideal 2: base + bound register&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#definition&#34;&gt;Definition&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#base-bound&#34;&gt;Base + bound&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#trade-offs&#34;&gt;Trade-offs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#segmentation&#34;&gt;Segmentation&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#segmentation-mechanics&#34;&gt;Segmentation mechanics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#segmentation-example&#34;&gt;Segmentation example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#trade-offs-1&#34;&gt;Trade-offs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#fragmentation&#34;&gt;Fragmentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#alternatives-to-hardware-mmu&#34;&gt;Alternatives to hardware MMU&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#paging&#34;&gt;Paging&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#trade-offs-2&#34;&gt;Trade-offs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#simplified-allocation&#34;&gt;Simplified allocation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#paging-data-structures&#34;&gt;Paging data structures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#example-paging-on-pdp-11&#34;&gt;Example: Paging on PDP-11&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;


&lt;h2 id=&#34;issues-in-sharing-physical-memory&#34;&gt;Issues in sharing physical memory&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/post/WX20171226-152306.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Protection

&lt;ul&gt;
&lt;li&gt;A bug in one process can corrupt in another&lt;/li&gt;
&lt;li&gt;Must somehow prevent process A from trashing B&amp;rsquo;s memory&lt;/li&gt;
&lt;li&gt;Also prevent A from even observing B&amp;rsquo;s memory (ssh-agent)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Transparency

&lt;ul&gt;
&lt;li&gt;A process shouldn&amp;rsquo;t require particular physical memory bits&lt;/li&gt;
&lt;li&gt;Yet processes often require large amounts of contiguous memory (for stack, large data structures, etc.)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Resource exhaustion

&lt;ul&gt;
&lt;li&gt;Programmers typically assume machine has &amp;ldquo;enough&amp;rdquo; memory&lt;/li&gt;
&lt;li&gt;Sum of sizes of all processes often greater than physical memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;virtual-memory&#34;&gt;Virtual memory&lt;/h2&gt;

&lt;h3 id=&#34;goals&#34;&gt;goals&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Give each program its own &lt;em&gt;virtual&lt;/em&gt; address space

&lt;ul&gt;
&lt;li&gt;At runtime, &lt;strong&gt;Memory-Management Unit (MMU)&lt;/strong&gt; relocates each load/store&lt;/li&gt;
&lt;li&gt;Application doesn&amp;rsquo;t see physical memory addresses&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Also enforce protection

&lt;ul&gt;
&lt;li&gt;Prevent one app from messing with another&amp;rsquo;s memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;And allow programs to see more memory than exists

&lt;ul&gt;
&lt;li&gt;Somehow relocate some memory accesses to disk&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;virtual-memory-advantages&#34;&gt;Virtual memory advantages&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Can relocate program while running

&lt;ul&gt;
&lt;li&gt;Run partially in memory, partially on disk&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Most of a process&amp;rsquo;s memory may be idle (&lt;sup&gt;80&lt;/sup&gt;&amp;frasl;&lt;sub&gt;20&lt;/sub&gt; rule)

&lt;ul&gt;
&lt;li&gt;&lt;img src=&#34;/img/post/WX20171226-153927.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;li&gt;Write idle parts to disk until needed&lt;/li&gt;
&lt;li&gt;Let other processes use memory of idle part&lt;/li&gt;
&lt;li&gt;Like CPU virtualization: when process not using CPU, switch (Not using amemory region? switch it to another process)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Challenge: VM = extra layer, could be slow&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ideas&#34;&gt;Ideas&lt;/h2&gt;

&lt;h3 id=&#34;ideal-1-load-time-linking&#34;&gt;Ideal 1: load-time linking&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/img/post/WX20171226-154928.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;Linker&lt;/em&gt; patches addresses of symbols like printf&lt;/li&gt;
&lt;li&gt;Idea: link when process executed, not at compile time

&lt;ul&gt;
&lt;li&gt;Determine where process will reside in memory&lt;/li&gt;
&lt;li&gt;Adjust all refernces within program (using addtion)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Problems?

&lt;ul&gt;
&lt;li&gt;How to enforce protection?&lt;/li&gt;
&lt;li&gt;How to move once already in memory? (consider data pointers)&lt;/li&gt;
&lt;li&gt;What if no contiguous free region fits program?&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ideal-2-base-bound-register&#34;&gt;Ideal 2: base + bound register&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/img/post/WX20171226-163437.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Two special privileged registers: &lt;strong&gt;base&lt;/strong&gt; snf &lt;strong&gt;bound&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;On each load/store/jump:

&lt;ul&gt;
&lt;li&gt;Physical address = virtual address + base&lt;/li&gt;
&lt;li&gt;Check 0 ≤ vitual address ≤ bound, else trap to kernel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;How to move process in memory?

&lt;ul&gt;
&lt;li&gt;Change base register&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;What happens on context switch?

&lt;ul&gt;
&lt;li&gt;OS must re-load base and bound register&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;definition&#34;&gt;Definition&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Programs load/store to &lt;code&gt;virtual addresses&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Actual memory uses &lt;code&gt;physical addresses&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;VM Hardware is Memory Management Unit (&lt;code&gt;MMU&lt;/code&gt;)

&lt;ul&gt;
&lt;li&gt;Usually part of CPU&lt;/li&gt;
&lt;li&gt;Configured through privileged instructions (e.g., load bound reg)&lt;/li&gt;
&lt;li&gt;Translates from virtual to physical addresses&lt;/li&gt;
&lt;li&gt;Gives per-process view of memory called &lt;code&gt;address space&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;base-bound&#34;&gt;Base + bound&lt;/h2&gt;

&lt;h3 id=&#34;trade-offs&#34;&gt;Trade-offs&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Advantages

&lt;ul&gt;
&lt;li&gt;Cheap in terms of hardware: only two registers&lt;/li&gt;
&lt;li&gt;Cheap in terms of cycles: do add and compare in parallel&lt;/li&gt;
&lt;li&gt;Examples: Cray-1 used this scheme&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disadvantages

&lt;ul&gt;
&lt;li&gt;Growing a process is expensive or impossible&lt;/li&gt;
&lt;li&gt;No way to share code or data (E.g., two copies of bochs, both running pintos)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;One solution: Multiple segments

&lt;ul&gt;
&lt;li&gt;E.g., separate code, stack, data segments&lt;/li&gt;
&lt;li&gt;Possibly multiple data segments&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;segmentation&#34;&gt;Segmentation&lt;/h2&gt;

&lt;p&gt;&lt;img src=&#34;/img/post/WX20171226-164915.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Let processes have many base/bound regs

&lt;ul&gt;
&lt;li&gt;Address space built from many segments&lt;/li&gt;
&lt;li&gt;Can share/protect memory at segment granularity&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Must specify segment as part of virtual address&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;segmentation-mechanics&#34;&gt;Segmentation mechanics&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/img/post/WX20171226-191449.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each process has a segment table&lt;/li&gt;
&lt;li&gt;Each VA (Virtual Address) indicates a segment and offset:

&lt;ul&gt;
&lt;li&gt;Top bits of addr select segment, low bits select offset (PDP-10)&lt;/li&gt;
&lt;li&gt;Or segment selected by instruction or operand (means you need wider &amp;ldquo;far&amp;rdquo; pointers to specify segment)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;segmentation-example&#34;&gt;Segmentation example&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/img/post/WX20171226-192145.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;2-bit segment number (1st digit), 12 bit offset (last 3)

&lt;ul&gt;
&lt;li&gt;Where is 0x0&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;trade-offs-1&#34;&gt;Trade-offs&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Advantages

&lt;ul&gt;
&lt;li&gt;Multiple segments per process&lt;/li&gt;
&lt;li&gt;Allows sharing!&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t need entire process in memory&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Disadvantages

&lt;ul&gt;
&lt;li&gt;Requires translation hardware, which could limit performance&lt;/li&gt;
&lt;li&gt;Segments not completely transparent to program (e.g., default segment faster or uses shorter instruction)&lt;/li&gt;
&lt;li&gt;$n$ byte segment needs &lt;em&gt;n contiguous&lt;/em&gt; bytes of physical memory&lt;/li&gt;
&lt;li&gt;Makes &lt;em&gt;fragmentation&lt;/em&gt; a real problem&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;fragmentation&#34;&gt;Fragmentation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Fragmentation =&amp;gt; Inability to use free memory&lt;/li&gt;
&lt;li&gt;Over time:

&lt;ul&gt;
&lt;li&gt;Variable-sized pices = many small holes (external fragmentation)&lt;/li&gt;
&lt;li&gt;Fixed-sized pieces = no external holes, but force internal waste (internal fragmentation)
&lt;img src=&#34;/img/post/WX20171226-213655.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;alternatives-to-hardware-mmu&#34;&gt;Alternatives to hardware MMU&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Language-level protection (Java)

&lt;ul&gt;
&lt;li&gt;Single address space for different modules&lt;/li&gt;
&lt;li&gt;Language enforces isolation&lt;/li&gt;
&lt;li&gt;Singularity OS does this&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Software fault isolation

&lt;ul&gt;
&lt;li&gt;Instrument compiler output&lt;/li&gt;
&lt;li&gt;Checks before ever ystore operation prevents modules from trashing each other&lt;/li&gt;
&lt;li&gt;Google Native Client does this&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;paging&#34;&gt;Paging&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Divede memory up into small &lt;em&gt;pages&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Map virtual pages to physical pages

&lt;ul&gt;
&lt;li&gt;Each process has separate mapping&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Allow OS to gain control on certain operation

&lt;ul&gt;
&lt;li&gt;Read-only pages trap to OS on write&lt;/li&gt;
&lt;li&gt;Invalid pages trap to OS on read or write&lt;/li&gt;
&lt;li&gt;OS can change mapping and resume application&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Other features sometimes found:

&lt;ul&gt;
&lt;li&gt;Hardware can set &amp;ldquo;accessed&amp;rdquo; and &amp;ldquo;dirty&amp;rdquo; bits&lt;/li&gt;
&lt;li&gt;Control page execute permission separately from read/write&lt;/li&gt;
&lt;li&gt;Control caching or memory consistency of page&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;trade-offs-2&#34;&gt;Trade-offs&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Eliminates external fragmentation&lt;/li&gt;
&lt;li&gt;Simplifies allocation, free, and backing storage (swap)&lt;/li&gt;
&lt;li&gt;Average internal fragmentation of .5 pages per &amp;ldquo;segment&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;simplified-allocation&#34;&gt;Simplified allocation&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Allocate any physical page to any process&lt;/li&gt;
&lt;li&gt;Can store idle virtual pages on disk&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;paging-data-structures&#34;&gt;Paging data structures&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Pages are fixed size, e.g., 4K

&lt;ul&gt;
&lt;li&gt;Least significant 12 ($log_{2}4K$) bits of address are page offset&lt;/li&gt;
&lt;li&gt;Most significant bits are &lt;em&gt;page number&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Each process has a page table

&lt;ul&gt;
&lt;li&gt;Maps &lt;em&gt;virtual page numbers (VPNs)&lt;/em&gt; to &lt;em&gt;physical page numbers (PPNS)&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;Also includes bits for protection, validity, etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;On memory access: Translate VPN to PPN, then add offset
&lt;img src=&#34;/img/post/WX20171227-094654.png&#34; alt=&#34;&#34; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;example-paging-on-pdp-11&#34;&gt;Example: Paging on PDP-11&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;64K virtual memory, 8K pages

&lt;ul&gt;
&lt;li&gt;Separate address space for instructions &amp;amp; data&lt;/li&gt;
&lt;li&gt;I.e., can&amp;rsquo;t read your own instructions with a load&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Entire page table stored in registers

&lt;ul&gt;
&lt;li&gt;8 Instruction page translation&lt;/li&gt;
&lt;li&gt;8 Data page translation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Swap 16 machine registers on each context switch&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2017-12-12</title>
      <link>/post/til-2017-12-12/</link>
      <pubDate>Tue, 12 Dec 2017 00:38:00 +0000</pubDate>
      
      <guid>/post/til-2017-12-12/</guid>
      <description>

&lt;h2&gt;Table of Contents&lt;/h2&gt;
&lt;nav id=&#34;TableOfContents&#34;&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#note-deep-learning-practice-and-trends-nips-2017&#34;&gt;[Note] Deep Learning: Practice and Trends (NIPS 2017)&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#practice&#34;&gt;Practice&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#architectures&#34;&gt;Architectures&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#recurrent-nets&#34;&gt;Recurrent Nets&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#trends&#34;&gt;Trends&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#autoregressive-models&#34;&gt;Autoregressive Models&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#domain-alignment-unsupervised&#34;&gt;Domain Alignment (unsupervised)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#learning-to-learn-meta-learning&#34;&gt;Learning to Learn / Meta Learning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conclusions-and-expectations&#34;&gt;Conclusions and Expectations&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/nav&gt;


&lt;h1 id=&#34;note-deep-learning-practice-and-trends-nips-2017&#34;&gt;[Note] Deep Learning: Practice and Trends (NIPS 2017)&lt;/h1&gt;

&lt;h2 id=&#34;practice&#34;&gt;Practice&lt;/h2&gt;

&lt;h3 id=&#34;architectures&#34;&gt;Architectures&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Convolutional Nets

&lt;ul&gt;
&lt;li&gt;Locality: objects tend to have a local spatial support

&lt;ul&gt;
&lt;li&gt;locally-connected&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Teanslation invariance: object appearance is independent of location&lt;/li&gt;
&lt;li&gt;Tricks of the Trade

&lt;ul&gt;
&lt;li&gt;Optimization

&lt;ul&gt;
&lt;li&gt;SGD with momentum&lt;/li&gt;
&lt;li&gt;Batch Norm&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Initialization

&lt;ul&gt;
&lt;li&gt;Weight init: start from the weights which lead to stable training&lt;/li&gt;
&lt;li&gt;Sample from zero-mean normal distribution w/ small variance 0.01

&lt;ul&gt;
&lt;li&gt;Adaptively choose variance for each layer

&lt;ul&gt;
&lt;li&gt;preserve gradient magnitude: 1/sqrt(fan_in)&lt;/li&gt;
&lt;li&gt;works fine for VGGNets (up to 20 layers), but not sufficient for deeper nets&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Model

&lt;ul&gt;
&lt;li&gt;Stacking 3x3 convolutions&lt;/li&gt;
&lt;li&gt;Inception&lt;/li&gt;
&lt;li&gt;ResNet adds modules which ensure that the gradient doesn&amp;rsquo;t vanish&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;recurrent-nets&#34;&gt;Recurrent Nets&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Two Key Ingredients: Neural Embeddings, Recurrent Language Models&lt;/li&gt;
&lt;li&gt;Dot product Attention

&lt;ul&gt;
&lt;li&gt;Inputs: &amp;ldquo;I am a cat&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Input RNN states: $e_1e_2e_3e_4$&lt;/li&gt;
&lt;li&gt;Decoder RNN state at step i (query): $h_i$&lt;/li&gt;
&lt;li&gt;Compute scalars $h_i^Te_1, h_i^Te_2,&amp;hellip;$representing similarity / relevance between encoder steps and query&lt;/li&gt;
&lt;li&gt;Normaliza $[h_i^Te_1,h_i^Te_2,&amp;hellip;]$ with softmax to produce attention weights&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tricks of the Trade

&lt;ul&gt;
&lt;li&gt;Long sequences?

&lt;ul&gt;
&lt;li&gt;Attention&lt;/li&gt;
&lt;li&gt;Bigger state&lt;/li&gt;
&lt;li&gt;Reverse inputs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Can&amp;rsquo;t overfit?

&lt;ul&gt;
&lt;li&gt;Bigger hidden state&lt;/li&gt;
&lt;li&gt;Deep LSTM + Skip Connections&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Overfit?

&lt;ul&gt;
&lt;li&gt;Dropout + Ensembles&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Tuning

&lt;ul&gt;
&lt;li&gt;Keep calm and decrease your learning rate&lt;/li&gt;
&lt;li&gt;Initalization of parameters is critical (in seq2seq we used U(-0.05, 0.05))&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Clip the gradients!&lt;/strong&gt;

&lt;ul&gt;
&lt;li&gt;E.g. if ||grad|| &amp;gt; 5: grad = grad/||grad|| * 5&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Attention and Memory Toolbox

&lt;ul&gt;
&lt;li&gt;Read/Write memories (neural turing machine)&lt;/li&gt;
&lt;li&gt;Sequence Prediction&lt;/li&gt;
&lt;li&gt;Seq2Seq&lt;/li&gt;
&lt;li&gt;Temporal Hierarchies&lt;/li&gt;
&lt;li&gt;Multimodality&lt;/li&gt;
&lt;li&gt;Attention/Pointers&lt;/li&gt;
&lt;li&gt;Recurrent Architectures&lt;/li&gt;
&lt;li&gt;Key, Value memories&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;trends&#34;&gt;Trends&lt;/h2&gt;

&lt;h3 id=&#34;autoregressive-models&#34;&gt;Autoregressive Models&lt;/h3&gt;

&lt;p&gt;$$P(x;\theta) = \prod_{n=1}^N P(x_n|x_n;\theta)$$&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Each factor can be parametrized by $\theta$, which can be shared&lt;/li&gt;
&lt;li&gt;The variables can be arbitrarily ordered and grouped, as long as the ordering and grouping is consistent.&lt;/li&gt;
&lt;li&gt;Building Blocks

&lt;ul&gt;
&lt;li&gt;Inputs and Outpus: these can also be conditioning variables

&lt;ul&gt;
&lt;li&gt;Image pixels&lt;/li&gt;
&lt;li&gt;Text sequences&lt;/li&gt;
&lt;li&gt;Audio waveforms&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Architectures

&lt;ul&gt;
&lt;li&gt;Recurrent, over space and time&lt;/li&gt;
&lt;li&gt;Causal convolutions&lt;/li&gt;
&lt;li&gt;Causal conv + attention&lt;/li&gt;
&lt;li&gt;Attention-only!&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Losses:

&lt;ul&gt;
&lt;li&gt;Discrete case: softmax cross entropy&lt;/li&gt;
&lt;li&gt;Continuous: Gaussian (mixture) likelihood&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Mixture of logistics loss&lt;/strong&gt; (PixelCNN++ in ICLR 2017)

&lt;ul&gt;
&lt;li&gt;$$ v ~ \sum_{i=1}^K \pi_i logistic(\mu_i,s_i) $$&lt;/li&gt;
&lt;li&gt;$$ P(x|\pi,\mu,s) = \sum_{i=1}^K \pi_i[\sigma((x+0.5-\mu_i)/s_i) - \sigma((x-0.5-\mu_i) / s_i)] $$&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Autogressive scoring and sampling

&lt;ul&gt;
&lt;li&gt;Fully sequential models:

&lt;ul&gt;
&lt;li&gt;PixelCNN, PixelCNN++, WaveNet, &amp;hellip;&lt;/li&gt;
&lt;li&gt;O(1) scoring, O(N) sampling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Models with conditional independence assumptions:

&lt;ul&gt;
&lt;li&gt;O(1) scoring, sampling can be O(1), O(log N), etc depending on cond. indep. assumptions&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Distilled models:

&lt;ul&gt;
&lt;li&gt;Parall WaveNet, Parallel NMT&lt;/li&gt;
&lt;li&gt;O(N) scoring, O(1) sampling&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;domain-alignment-unsupervised&#34;&gt;Domain Alignment (unsupervised)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Building Blocks

&lt;ul&gt;
&lt;li&gt;Inputs and Outpus

&lt;ul&gt;
&lt;li&gt;Sets of images with shared structure, but weak or no alignment&lt;/li&gt;
&lt;li&gt;Text corpora in different languages, but not parallel&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Architecures

&lt;ul&gt;
&lt;li&gt;Nothing fancy!&lt;/li&gt;
&lt;li&gt;For images: mostly convolutional nets&lt;/li&gt;
&lt;li&gt;For text: recurrent&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Losses

&lt;ul&gt;
&lt;li&gt;Latent space: Domain confusion&lt;/li&gt;
&lt;li&gt;Pixel space: Cycle consistency&lt;/li&gt;
&lt;li&gt;Both adversarial loss and likelihoods work!&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Approach

&lt;ul&gt;
&lt;li&gt;Cross-modal retrieval&lt;/li&gt;
&lt;li&gt;Unsupervised domain transfer for classification&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Case

&lt;ul&gt;
&lt;li&gt;DiscoGAN - Car2Face&lt;/li&gt;
&lt;li&gt;GraspGAN&lt;/li&gt;
&lt;li&gt;Unsupervised Neural Machine Translation&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;learning-to-learn-meta-learning&#34;&gt;Learning to Learn / Meta Learning&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Building Blocks:

&lt;ul&gt;
&lt;li&gt;Inputs and Outputs: text, images, actions&lt;/li&gt;
&lt;li&gt;Architectures: Recurrent, CNN (+attention)&lt;/li&gt;
&lt;li&gt;Losses (loss based on another loss): Model, Optimization, Initialization&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Learning to learn:

&lt;ul&gt;
&lt;li&gt;What is Meta Learning?

&lt;ul&gt;
&lt;li&gt;Go beyond train/test from same distribution&lt;/li&gt;
&lt;li&gt;Task between train/test changes, so model has to &amp;ldquo;learn to learn&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Model Based, Metric Based, Optimization Based&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;conclusions-and-expectations&#34;&gt;Conclusions and Expectations&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Deep autoregressive models and ConvNets are ubiquitous and already useful in consumer applications&lt;/li&gt;
&lt;li&gt;Inductive biases are useful

&lt;ul&gt;
&lt;li&gt;spatial invariance for CNNs&lt;/li&gt;
&lt;li&gt;time recurrence for RNNs&lt;/li&gt;
&lt;li&gt;Permutation invariance for Graphs&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Simple tricks like ResNet will be discovered&lt;/li&gt;
&lt;li&gt;Adversarial networks and unsupervised domain adaptation have interesting market app (e.g. phone apps like style transfer)&lt;/li&gt;
&lt;li&gt;Meta learning: more and more of the model lifecycle (train/val/test) will be learned in an end-to-end way&lt;/li&gt;
&lt;li&gt;Program syntesis + Graph networks may be very important and find more real-world applications (e.g. RobustFill)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2017-12-08</title>
      <link>/post/til-2017-12-08/</link>
      <pubDate>Fri, 08 Dec 2017 00:38:00 +0000</pubDate>
      
      <guid>/post/til-2017-12-08/</guid>
      <description>

&lt;h2 id=&#34;paper-daily&#34;&gt;Paper Daily&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Where Classification Fails, Interpretation Rises

&lt;ul&gt;
&lt;li&gt;apply an attention mechanism to the adversarial examples detection&lt;/li&gt;
&lt;li&gt;uisng attention to defend against adversarial examples&lt;/li&gt;
&lt;li&gt;(this paper is hard to read)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Deep Image Prior

&lt;ul&gt;
&lt;li&gt;randomly-initialized neural network can be used as a handcrafted prior with excellent results&lt;/li&gt;
&lt;li&gt;search in parameter space&lt;/li&gt;
&lt;li&gt;apply untrianed CNN, fit a G network to a single degraded image.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Deep Reinforcement Learning framework for Autonoumous Driving

&lt;ul&gt;
&lt;li&gt;Deep Deterministic Actor Critic (DDAC)

&lt;ul&gt;
&lt;li&gt;actor: provides the policy mapping from a state to action&lt;/li&gt;
&lt;li&gt;critic: evaluates the value of the action taken (same as Q-function)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;review-of-clustering-algorithms&#34;&gt;Review of clustering algorithms&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Clustering

&lt;ul&gt;
&lt;li&gt;k-means&lt;/li&gt;
&lt;li&gt;k-medoids&lt;/li&gt;
&lt;li&gt;Gaussian Mixture Model&lt;/li&gt;
&lt;li&gt;Spectral Clustering&lt;/li&gt;
&lt;li&gt;Hierachical Clustering&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Other relevant algorithms

&lt;ul&gt;
&lt;li&gt;Expecatation Maximization&lt;/li&gt;
&lt;li&gt;Dimendsionality Reduction

&lt;ul&gt;
&lt;li&gt;Laplacian Eigenmap&lt;/li&gt;
&lt;li&gt;Locally Linear Embedding&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&#34;computer-orgnisation&#34;&gt;Computer orgnisation&lt;/h1&gt;

&lt;ul&gt;
&lt;li&gt;Direct mapping

&lt;ul&gt;
&lt;li&gt;process is divided into pages&lt;/li&gt;
&lt;li&gt;main memory is divided into frames/blocks&lt;/li&gt;
&lt;li&gt;cache is divided into lines&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2017-12-05</title>
      <link>/post/til-2017-12-05/</link>
      <pubDate>Tue, 05 Dec 2017 00:38:00 +0000</pubDate>
      
      <guid>/post/til-2017-12-05/</guid>
      <description>

&lt;h2 id=&#34;paper-daily&#34;&gt;Paper Daily&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;(NIPS 2017) Visual Reference Resolution using Attention Memory for Visual Dialog, Paul Hongsuch Seo

&lt;ul&gt;
&lt;li&gt;An associative attention memory storing s sequence of previous (attention, key) pairs&lt;/li&gt;
&lt;li&gt;Retrieves the previous attention, taking into account recency, which is most relevant for the current Q&lt;/li&gt;
&lt;li&gt;Resoning ability, maybe the best single model (trained by mle) presently&lt;/li&gt;
&lt;li&gt;Other keywords, text as key, attention as value, aceess values according to key; Method is Attention over attention&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;computer-network-notes&#34;&gt;Computer Network Notes&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Classes (think in binary system)

&lt;ul&gt;
&lt;li&gt;CA: 1-126 ($2^{24}-2$)&lt;/li&gt;
&lt;li&gt;CB: 128-191 ($2^{16}-2$)&lt;/li&gt;
&lt;li&gt;CC: 192-223 ($2^8-2$)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;DBA: Directed Broadcast Address (NID, HID 1s [11.255.255.255])&lt;/li&gt;
&lt;li&gt;NID: (NID, HID 0s [11.0.0.0])&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;types-of-casting&#34;&gt;Types of casting&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Unicast&lt;/li&gt;
&lt;li&gt;Broadcast

&lt;ul&gt;
&lt;li&gt;Limited

&lt;ul&gt;
&lt;li&gt;11.0.0.0  |m|11.1.2.3 (Source Address)|255.255.255.255 (Destination Address)|&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Directed

&lt;ul&gt;
&lt;li&gt;11.0.0.0  |m|11.1.2.3|20.255.255.255|&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;subnets-subnet-mask-cidr&#34;&gt;Subnets, Subnet Mask, CIDR&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;subnetting disadvantage

&lt;ul&gt;
&lt;li&gt;reach the process complexly&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;The difference between in subnet and outside subnet;&lt;/li&gt;
&lt;li&gt;Every subnet waste two IP addresses for the NID and DBA

&lt;ul&gt;
&lt;li&gt;2 subnet: For CC: (128 - 2) x 2 = 252&lt;/li&gt;
&lt;li&gt;2 subnet: (200.1.2.0)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Subnet Mask: 32 bit

&lt;ul&gt;
&lt;li&gt;#1: #NID + #SID, #0: #HID&lt;/li&gt;
&lt;li&gt;can find out NID&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Variable lenght subnet masking (VLSM)&lt;/li&gt;
&lt;li&gt;Classless Inter Domain Routing

&lt;ul&gt;
&lt;li&gt;(a.b.c.d/n) n: #NID&lt;/li&gt;
&lt;li&gt;Rules of blocks

&lt;ul&gt;
&lt;li&gt;All IP addrees should be contiguous&lt;/li&gt;
&lt;li&gt;$2^n$&lt;/li&gt;
&lt;li&gt;Fast IP address in the block should be evenly divided by size of the block&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Subnetting in CIDR&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;operating-system-notes&#34;&gt;Operating System Notes&lt;/h2&gt;

&lt;h2 id=&#34;file-system&#34;&gt;File System&lt;/h2&gt;

&lt;h3 id=&#34;cache-memory&#34;&gt;cache memory&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Cache - Paging (main memory) - Secondary Memory

&lt;ul&gt;
&lt;li&gt;Hit latency: the time to hit in the cache&lt;/li&gt;
&lt;li&gt;Cache hit: a state in which data requested for processing by a component or application is found in the cache memory&lt;/li&gt;
&lt;li&gt;Cache miss: not found&lt;/li&gt;
&lt;li&gt;Miss latency: the time (in cycles) the CPU waits when a miss happen in the cache&lt;/li&gt;
&lt;li&gt;Page fault, Page hit&lt;/li&gt;
&lt;li&gt;Spatial/temporal locality&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Direct Mapping

&lt;ul&gt;
&lt;li&gt;[Tag | Index (line number)| (block) Offset]&lt;/li&gt;
&lt;li&gt;$2^m$ addresses&lt;/li&gt;
&lt;li&gt;$2^k$ cache entries&lt;/li&gt;
&lt;li&gt;$2^n$ block size&lt;/li&gt;
&lt;li&gt;Step:

&lt;ul&gt;
&lt;li&gt;Use the index part of the address to find the appropriate cache entry&lt;/li&gt;
&lt;li&gt;CHeck the tag to see if the entry contains the right data&lt;/li&gt;
&lt;li&gt;If it does, then use the offset to the find the correct byte&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>End-to-end Deep Models for Self-driving Car (Avaliable soon)</title>
      <link>/talk/end-to-end-deep-models-for-self-driving-car/</link>
      <pubDate>Sun, 26 Nov 2017 19:00:00 +0000</pubDate>
      
      <guid>/talk/end-to-end-deep-models-for-self-driving-car/</guid>
      <description>

&lt;hr /&gt;

&lt;h2 id=&#34;reference&#34;&gt;Reference:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Huval, Brody, et al. &amp;ldquo;An empirical evaluation of deep learning on highway driving.&amp;ldquo; arXiv preprint arXiv:1504.01716 (2015).&lt;/li&gt;
&lt;li&gt;Ulbrich, Simon, et al. &amp;ldquo;Towards a Functional System Architecture for Automated Vehicles.&amp;ldquo; arXiv preprint arXiv:1703.08557 (2017).&lt;/li&gt;
&lt;li&gt;Pomerleau, Dean A. &amp;ldquo;Alvinn: An autonomous land vehicle in a neural network.&amp;ldquo; 
Advances in neural information processing systems. 1989.&lt;/li&gt;
&lt;li&gt;Muller, Urs, et al. &amp;ldquo;Off-road obstacle avoidance through end-to-end learning.“ Advances in neural information processing systems. 2006.APA&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Chen, Chenyi, et al. &amp;ldquo;Deepdriving: Learning affordance for direct perception in autonomous driving.&amp;ldquo; Proceedings of the IEEE International Conference on Computer Vision. 2015.&lt;/li&gt;
&lt;li&gt;Chen, Chenyi, et al. &amp;ldquo;Deepdriving: Learning affordance for direct perception in autonomous driving.&amp;ldquo; Proceedings of the IEEE International Conference on Computer Vision. 2015.&lt;/li&gt;
&lt;li&gt;Bojarski, Mariusz, et al. &amp;ldquo;End to end learning for self-driving cars.&amp;ldquo; arXiv preprint arXiv:1604.07316 (2016).&lt;/li&gt;
&lt;li&gt;Codevilla, Felipe, et al. &amp;ldquo;End-to-end driving via conditional imitation learning.&amp;ldquo; arXiv preprint arXiv:1710.02410 (2017).&lt;/li&gt;
&lt;li&gt;Xu, Huazhe, et al. &amp;ldquo;End-to-end learning of driving models from large-scale video datasets.&amp;ldquo; arXiv preprint arXiv:1612.01079(2016).&lt;/li&gt;
&lt;li&gt;Mukadam, Mustafa, et al. “Tactical Decision Making for Lane Changing with Deep Reinforcement Learning.&amp;rdquo; (2017).&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>卷积神经网络：从相遇相知到相爱</title>
      <link>/talk/cnn/</link>
      <pubDate>Fri, 10 Nov 2017 19:00:00 +0000</pubDate>
      
      <guid>/talk/cnn/</guid>
      <description>&lt;hr /&gt;

&lt;script async class=&#39;speakerdeck-embed&#39; data-id=&#39;7aba17f26f474cb9aebb0ffba3c11446&#39; data-ratio=&#39;1.33333333333333&#39; src=&#39;//speakerdeck.com/assets/embed.js&#39;&gt;&lt;/script&gt;
</description>
    </item>
    
    <item>
      <title>如何实现无人驾驶</title>
      <link>/talk/how-to-build-self-driving-car/</link>
      <pubDate>Fri, 20 Oct 2017 19:00:00 +0000</pubDate>
      
      <guid>/talk/how-to-build-self-driving-car/</guid>
      <description>&lt;p&gt;MIL 智能体组无人驾驶汽车项目介绍&lt;/p&gt;

&lt;hr /&gt;
</description>
    </item>
    
    <item>
      <title>Deep Reinforcement Learning</title>
      <link>/talk/deep-reinforcemnt-learning/</link>
      <pubDate>Mon, 28 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/talk/deep-reinforcemnt-learning/</guid>
      <description>&lt;script async class=&#39;speakerdeck-embed&#39; data-id=&#39;62b49c13db9b4b61a97bc64140d96453&#39; data-ratio=&#39;1.33333333333333&#39; src=&#39;//speakerdeck.com/assets/embed.js&#39;&gt;&lt;/script&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Markov Decision Processes&lt;/li&gt;
&lt;li&gt;Policy Learning and Value Learning&lt;/li&gt;
&lt;li&gt;Bellman Equation&lt;/li&gt;
&lt;li&gt;Model-based and Model-free&lt;/li&gt;
&lt;li&gt;Q-learning, Policy Gradients, Actor-Critic&lt;/li&gt;
&lt;li&gt;Experience Replay&lt;/li&gt;
&lt;li&gt;Applications: Atari Game, Recurrent Attention Model(RAM)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Referfence and Recommend Materials&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;CS231n: Deep Reinforcement Learning (&lt;a href=&#34;https://www.youtube.com/watch?v=lvoHnicueoE&amp;amp;index=14&amp;amp;list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk&#34; target=&#34;_blank&#34;&gt;Video&lt;/a&gt;) (&lt;a href=&#34;http://cs231n.stanford.edu/slides/2017/cs231n_2017_lecture14.pdf&#34; target=&#34;_blank&#34;&gt;Slide&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://arxiv.org/abs/1312.5602&#34; target=&#34;_blank&#34;&gt;Playing Atari with Deep Reinforcement Learning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://arxiv.org/abs/1406.6247&#34; target=&#34;_blank&#34;&gt;Recurrent Models of Visual Attention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/MorvanZhou/Reinforcement-learning-with-tensorflow&#34; target=&#34;_blank&#34;&gt;Reinforcement Learning Methods and Tutorials&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Intro to Reinforcement Learning</title>
      <link>/talk/reinforcement-learning/</link>
      <pubDate>Wed, 23 Aug 2017 00:00:00 +0000</pubDate>
      
      <guid>/talk/reinforcement-learning/</guid>
      <description>&lt;script async class=&#39;speakerdeck-embed&#39; data-id=&#39;2b0ad1af004f4266b693269e394f35cf&#39; data-ratio=&#39;1.33333333333333&#39; src=&#39;//speakerdeck.com/assets/embed.js&#39;&gt;&lt;/script&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;Markov Decision Processes&lt;/li&gt;
&lt;li&gt;Model-based and Model-free&lt;/li&gt;
&lt;li&gt;Value Iteration and Policy Iteration&lt;/li&gt;
&lt;li&gt;Q-learning and approximate Q-learning&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Referfence and Recommend Materials&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zhuanlan.zhihu.com/p/25319023&#34; target=&#34;_blank&#34;&gt;强化学习（Reinforcement Learning）知识整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;UC Berkeley CS188 Intro to AI&#34; target=&#34;_blank&#34;&gt;UC Berkeley CS188 Intro to AI&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Markov Decision Processe

&lt;ul&gt;
&lt;li&gt;(&lt;a href=&#34;http://www.youtube.com/watch?v=Oxqwwnm_x0s&#34; target=&#34;_blank&#34;&gt;lecture I&lt;/a&gt;) (&lt;a href=&#34;http://www.youtube.com/watch?v=6pBvbLyn6fE&#34; target=&#34;_blank&#34;&gt;lecture II&lt;/a&gt;) (&lt;a href=&#34;http://ai.berkeley.edu/slides/Lecture%208%20--%20MDPs%20I/SP14%20CS188%20Lecture%208%20--%20MDPs%20I.pptx&#34; target=&#34;_blank&#34;&gt;PPT I&lt;/a&gt;) (&lt;a href=&#34;http://ai.berkeley.edu/slides/Lecture%209%20--%20MDPs%20II/SP14%20CS188%20Lecture%209%20--%20MDPs%20II.pptx&#34; target=&#34;_blank&#34;&gt;PPT II&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Reinforcement Learning

&lt;ul&gt;
&lt;li&gt;(&lt;a href=&#34;http://www.youtube.com/watch?v=IXuHxkpO5E8&#34; target=&#34;_blank&#34;&gt;lecture I&lt;/a&gt;) (&lt;a href=&#34;http://www.youtube.com/watch?v=yNeSFbE1jdY&#34; target=&#34;_blank&#34;&gt;lecture II&lt;/a&gt;) (&lt;a href=&#34;http://ai.berkeley.edu/slides/Lecture%2010%20--%20Reinforcement%20Learning%20I/SP14%20CS188%20Lecture%2010%20--%20Reinforcement%20Learning%20I.pptx&#34; target=&#34;_blank&#34;&gt;PPT I&lt;/a&gt;) (&lt;a href=&#34;http://ai.berkeley.edu/slides/Lecture%2011%20--%20Reinforcement%20Learning%20II/SP14%20CS188%20Lecture%2011%20--%20Reinforcement%20Learning%20II.pptx&#34; target=&#34;_blank&#34;&gt;PPT II&lt;/a&gt;)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>An Quadrotor Safety Monitorting System</title>
      <link>/project/an-quadrotor-safety-monitorting-system/</link>
      <pubDate>Thu, 01 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>/project/an-quadrotor-safety-monitorting-system/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;Implemented and optimized a anomaly detection algorithm called Isolation Forest, which can receive temporal information and feed back the abnormal degree.&lt;/li&gt;
&lt;li&gt;Developed an exploration tool for the iForest algorithm, which can do visualization to a certain extent&lt;/li&gt;
&lt;li&gt;Won Provincial 1st Prizes both in the 2017 Challenge Cup and the E-Commerce Competition, Technical group. And get the qualification to the 2017 national contests.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Predicting Rossmann Store Sales</title>
      <link>/project/rossmann/</link>
      <pubDate>Sun, 19 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/project/rossmann/</guid>
      <description>&lt;p&gt;Rossmann operates over 3,000 drug stores in 7 European countries. Currently, Rossmann store managers are tasked with predicting their daily sales for up to six weeks in advance. Store sales are influenced by many factors, including promotions, competition, school and state holidays, seasonality, and locality. With thousands of individual managers predicting sales based on their unique circumstances, the accuracy of results can be quite varied.&lt;/p&gt;

&lt;p&gt;In their first Kaggle competition, Rossmann is challenging you to predict 6 weeks of daily sales for 1,115 stores located across Germany. Reliable sales forecasts enable store managers to create effective staff schedules that increase productivity and motivation. By helping Rossmann create a robust prediction model, you will help store managers stay focused on what’s most important to them: their customers and their teams!&lt;/p&gt;

&lt;p&gt;(There are a lot of flaws due to lack of time.)
You can see the report &lt;a href=&#34;https://github.com/wolegechu/Machine_Learning_Nanodegree/tree/master/Capstone&#34; target=&#34;_blank&#34;&gt;there&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Digit Recognition Program</title>
      <link>/project/digit_recognition/</link>
      <pubDate>Thu, 16 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/project/digit_recognition/</guid>
      <description>&lt;p&gt;In this project, I used deep neural networks and convolutional neural networks to create a program that prints numbers it observes in real time from images it is given. First, I designed and tested a model architecture that can identify sequences of digits in an image. Next, I trained that model so it could decode sequences of digits from natural images by using the Street View House Numbers (SVHN) dataset. After the model was properly trained, I then tested my model using a program on newly-captured images. Finally, I refined your implementation to also localize where numbers are on the image, and test this localization on newly-captured images.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The main techniques used:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Deep Neural Networks&lt;/li&gt;
&lt;li&gt;Convolutional Neural Networks&lt;/li&gt;
&lt;li&gt;Adadelta&lt;/li&gt;
&lt;li&gt;Keras based on TensorFlow&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can see the code(iPython notebook) &lt;a href=&#34;https://github.com/wolegechu/Machine_Learning_Nanodegree/blob/master/5.%20Digit%20Recognition/digit_recognition.ipynb&#34; target=&#34;_blank&#34;&gt;there&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Train a Smartcab How to Drive</title>
      <link>/project/smartcab/</link>
      <pubDate>Tue, 14 Mar 2017 00:00:00 +0000</pubDate>
      
      <guid>/project/smartcab/</guid>
      <description>

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;In this project I applied reinforcement learning techniques for a self-driving agent in a simplified world to aid it in effectively reaching its destinations in the allotted time. I first investigated the environment the agent operates in by constructing a very basic driving implementation. Once the agent is successful at operating within the environment, I then identified each possible state the agent can be in when considering such things as traffic lights and oncoming traffic at each intersection. With states identified, I then implemented a Q-Learning algorithm for the self-driving agent to guide the agent towards its destination within the allotted time. Finally, I improved upon the Q-Learning algorithm to find the best configuration of learning and exploration factors to ensure the self-driving agent is reaching its destinations with consistently positive results.&lt;/p&gt;

&lt;h2 id=&#34;description&#34;&gt;Description&lt;/h2&gt;

&lt;p&gt;In the not-so-distant future, taxicab companies across the United States no longer employ human drivers to operate their fleet of vehicles. Instead, the taxicabs are operated by self-driving agents, known as &lt;em&gt;smartcabs&lt;/em&gt;, to transport people from one location to another within the cities those companies operate. In major metropolitan areas, such as Chicago, New York City, and San Francisco, an increasing number of people have come to depend on &lt;em&gt;smartcabs&lt;/em&gt; to get to where they need to go as safely and reliably as possible. Although &lt;em&gt;smartcabs&lt;/em&gt; have become the transport of choice, concerns have arose that a self-driving agent might not be as safe or reliable as human drivers, particularly when considering city traffic lights and other vehicles. To alleviate these concerns, my task is to use reinforcement learning techniques to construct a demonstration of a &lt;em&gt;smartcab&lt;/em&gt; operating in real-time to prove that both safety and reliability can be achieved.&lt;/p&gt;

&lt;h3 id=&#34;below-is-the-final-score&#34;&gt;Below is the final score:&lt;/h3&gt;

&lt;p&gt;&lt;img src=&#34;/img/posters/smartcab.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;the-main-techniques-used&#34;&gt;The main techniques used:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Markov Decision Processes&lt;/li&gt;
&lt;li&gt;Reinforcement Learning&lt;/li&gt;
&lt;li&gt;Game Theory&lt;/li&gt;
&lt;li&gt;More Game Theory beginning at Stochastic games and Multi-agent RL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;You can see the code(iPython notebook) &lt;a href=&#34;https://github.com/wolegechu/Machine_Learning_Nanodegree/blob/master/4.%20Smartcab/smartcab.ipynb&#34; target=&#34;_blank&#34;&gt;there&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
